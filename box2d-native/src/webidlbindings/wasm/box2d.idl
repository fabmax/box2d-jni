//
// Emscripten / Web IDL Binder compatible .idl file
// Generated by webidl-util from model Box2d
//

[NoDelete]
interface B2_AABB {
    static boolean contains([Ref] b2AABB a, [Ref] b2AABB b);
    static void center([Ref] b2AABB a, [Ref] b2Vec2 result);
    static void extents([Ref] b2AABB a, [Ref] b2Vec2 result);
    static void unionAABB([Ref] b2AABB a, [Ref] b2AABB b, [Ref] b2AABB result);
    static boolean overlaps([Ref] b2AABB a, [Ref] b2AABB b);
    static boolean isValid([Ref] b2AABB aabb);
};

[NoDelete]
interface B2_Base {
    [Value] static b2Version getVersion();
    static long getByteCount();
    static unsigned long long storeWorldId([Ref] b2WorldId worldId);
    static void loadWorldId(unsigned long long worldId, [Ref] b2WorldId result);
    static unsigned long long storeBodyId([Ref] b2BodyId bodyId);
    static void loadBodyId(unsigned long long bodyId, [Ref] b2BodyId result);
    static unsigned long long storeShapeId([Ref] b2ShapeId shapeId);
    static void loadShapeId(unsigned long long shapeId, [Ref] b2ShapeId result);
    static unsigned long long storeChainId([Ref] b2ChainId chainId);
    static void loadChainId(unsigned long long chainId, [Ref] b2ChainId result);
    static unsigned long long storeJointId([Ref] b2JointId jointId);
    static void loadJointId(unsigned long long jointId, [Ref] b2JointId result);
};

[NoDelete]
interface B2_Body {
    static void defaultBodyDef([Ref] b2BodyDef result);
    static unsigned long long createBody(unsigned long long worldId, [Const] b2BodyDef def);
    static void destroyBody(unsigned long long bodyId);
    static boolean isValid(unsigned long long bodyId);
    static b2BodyType getType(unsigned long long bodyId);
    static void setType(unsigned long long bodyId, b2BodyType type);
    [Value] static b2Vec2 getPosition(unsigned long long bodyId);
    [Value] static b2Rot getRotation(unsigned long long bodyId);
    [Value] static b2Transform getTransform(unsigned long long bodyId);
    static void setTransform(unsigned long long bodyId, [Ref] b2Vec2 position, [Ref] b2Rot rotation);
    [Value] static b2AABB computeAABB(unsigned long long bodyId);
    [Value] static b2Vec2 getLocalPoint(unsigned long long bodyId, [Ref] b2Vec2 worldPoint);
    [Value] static b2Vec2 getWorldPoint(unsigned long long bodyId, [Ref] b2Vec2 localPoint);
    [Value] static b2Vec2 getLocalVector(unsigned long long bodyId, [Ref] b2Vec2 worldVector);
    [Value] static b2Vec2 getWorldVector(unsigned long long bodyId, [Ref] b2Vec2 localVector);
    [Value] static b2Vec2 getLinearVelocity(unsigned long long bodyId);
    static float getAngularVelocity(unsigned long long bodyId);
    static void setLinearVelocity(unsigned long long bodyId, [Ref] b2Vec2 linearVelocity);
    static void setAngularVelocity(unsigned long long bodyId, float angularVelocity);
    static void setTargetTransform(unsigned long long bodyId, [Ref] b2Transform target, float timeStep);
    [Value] static b2Vec2 getLocalPointVelocity(unsigned long long bodyId, [Ref] b2Vec2 localPoint);
    [Value] static b2Vec2 getWorldPointVelocity(unsigned long long bodyId, [Ref] b2Vec2 worldPoint);
    static void applyForce(unsigned long long bodyId, [Ref] b2Vec2 force, [Ref] b2Vec2 point, boolean wake);
    static void applyForceToCenter(unsigned long long bodyId, [Ref] b2Vec2 force, boolean wake);
    static void applyTorque(unsigned long long bodyId, float torque, boolean wake);
    static void applyLinearImpulse(unsigned long long bodyId, [Ref] b2Vec2 impulse, [Ref] b2Vec2 point, boolean wake);
    static void applyLinearImpulseToCenter(unsigned long long bodyId, [Ref] b2Vec2 impulse, boolean wake);
    static void applyAngularImpulse(unsigned long long bodyId, float impulse, boolean wake);
    static float getMass(unsigned long long bodyId);
    static float getRotationalInertia(unsigned long long bodyId);
    [Value] static b2Vec2 getLocalCenterOfMass(unsigned long long bodyId);
    [Value] static b2Vec2 getWorldCenterOfMass(unsigned long long bodyId);
    static void setMassData(unsigned long long bodyId, [Ref] b2MassData massData);
    [Value] static b2MassData getMassData(unsigned long long bodyId);
    static void applyMassFromShapes(unsigned long long bodyId);
    static void setLinearDamping(unsigned long long bodyId, float linearDamping);
    static float getLinearDamping(unsigned long long bodyId);
    static void setAngularDamping(unsigned long long bodyId, float angularDamping);
    static float getAngularDamping(unsigned long long bodyId);
    static void setGravityScale(unsigned long long bodyId, float gravityScale);
    static float getGravityScale(unsigned long long bodyId);
    static boolean isAwake(unsigned long long bodyId);
    static void setAwake(unsigned long long bodyId, boolean awake);
    static void enableSleep(unsigned long long bodyId, boolean enableSleep);
    static boolean isSleepEnabled(unsigned long long bodyId);
    static void setSleepThreshold(unsigned long long bodyId, float sleepThreshold);
    static float getSleepThreshold(unsigned long long bodyId);
    static boolean isEnabled(unsigned long long bodyId);
    static void disable(unsigned long long bodyId);
    static void enable(unsigned long long bodyId);
    static void setFixedRotation(unsigned long long bodyId, boolean flag);
    static boolean isFixedRotation(unsigned long long bodyId);
    static void setBullet(unsigned long long bodyId, boolean flag);
    static boolean isBullet(unsigned long long bodyId);
    [Value] static b2WorldId getWorld(unsigned long long bodyId);
    static long getShapeCount(unsigned long long bodyId);
    static long getShapes(unsigned long long bodyId, b2ShapeIdArray shapeArray);
    static long getJointCount(unsigned long long bodyId);
    static long getJoints(unsigned long long bodyId, b2JointIdArray jointArray);
    static void enableContactEvents(unsigned long long bodyId, boolean flag);
    static void enableHitEvents(unsigned long long bodyId, boolean flag);
    static long getContactCapacity(unsigned long long bodyId);
    static long getContactData(unsigned long long bodyId, b2ContactDataArray contactData);
    static void setName(unsigned long long bodyId, DOMString name);
    [Const] static DOMString getName(unsigned long long bodyId);
    static void setUserData(unsigned long long bodyId, VoidPtr userData);
    static VoidPtr getUserData(unsigned long long bodyId);
};

[NoDelete]
interface B2_Chain {
    static void defaultChainDef([Ref] b2ChainDef result);
    static unsigned long long createChain(unsigned long long bodyId, [Const] b2ChainDef def);
    static void destroyChain(unsigned long long chainId);
    static boolean isValid(unsigned long long id);
    [Value] static b2WorldId getWorld(unsigned long long chainId);
    static long getSegmentCount(unsigned long long chainId);
    static long getSegments(unsigned long long chainId, b2ShapeIdArray segmentArray);
    static void setFriction(unsigned long long chainId, float friction);
    static float getFriction(unsigned long long chainId);
    static void setRestitution(unsigned long long chainId, float restitution);
    static float getRestitution(unsigned long long chainId);
    static void setMaterial(unsigned long long chainId, long material);
    static long getMaterial(unsigned long long chainId);
};

[NoDelete]
interface B2_CharacterMover {
    [Value] static b2PlaneSolverResult solvePlanes([Ref] b2Vec2 targetDelta, b2CollisionPlaneArray planes);
    [Value] static b2Vec2 clipVector([Ref] b2Vec2 vector, [Const] b2CollisionPlaneArray planes);
};

[NoDelete]
interface B2_Distance {
    [Value] static b2SegmentDistanceResult segmentDistance([Ref] b2Vec2 p1, [Ref] b2Vec2 q1, [Ref] b2Vec2 p2, [Ref] b2Vec2 q2);
    [Value] static b2DistanceOutput shapeDistance([Const] b2DistanceInput input, b2SimplexCache cache, b2Simplex simplexes, long simplexCapacity);
    [Value] static b2CastOutput shapeCast([Const] b2ShapeCastPairInput input);
    [Value] static b2ShapeProxy makeProxy(b2Vec2Array points, float radius);
    [Value] static b2ShapeProxy makeOffsetProxy(b2Vec2Array points, float radius, [Ref] b2Vec2 position, [Ref] b2Rot rotation);
    static void getSweepTransform([Const] b2Sweep sweep, float time, [Ref] b2Transform result);
    [Value] static b2TOIOutput timeOfImpact([Const] b2TOIInput input);
};

[NoDelete]
interface B2_DistanceJoint {
    static unsigned long long createDistanceJoint(unsigned long long worldId, [Const] b2DistanceJointDef def);
    static void defaultDistanceJointDef([Ref] b2DistanceJointDef result);
    static void setLength(unsigned long long jointId, float length);
    static float getLength(unsigned long long jointId);
    static void enableSpring(unsigned long long jointId, boolean enableSpring);
    static boolean isSpringEnabled(unsigned long long jointId);
    static void setSpringHertz(unsigned long long jointId, float hertz);
    static void setSpringDampingRatio(unsigned long long jointId, float dampingRatio);
    static float getSpringHertz(unsigned long long jointId);
    static float getSpringDampingRatio(unsigned long long jointId);
    static void enableLimit(unsigned long long jointId, boolean enableLimit);
    static boolean isLimitEnabled(unsigned long long jointId);
    static void setLengthRange(unsigned long long jointId, float minLength, float maxLength);
    static float getMinLength(unsigned long long jointId);
    static float getMaxLength(unsigned long long jointId);
    static float getCurrentLength(unsigned long long jointId);
    static void enableMotor(unsigned long long jointId, boolean enableMotor);
    static boolean isMotorEnabled(unsigned long long jointId);
    static void setMotorSpeed(unsigned long long jointId, float motorSpeed);
    static float getMotorSpeed(unsigned long long jointId);
    static void setMaxMotorForce(unsigned long long jointId, float force);
    static float getMaxMotorForce(unsigned long long jointId);
    static float getMotorForce(unsigned long long jointId);
};

[NoDelete]
interface B2_FilterJoint {
    static unsigned long long createFilterJoint(unsigned long long worldId, [Const] b2FilterJointDef def);
    static void defaultFilterJointDef([Ref] b2FilterJointDef result);
};

[NoDelete]
interface B2_Geometry {
    static boolean isValidRay([Const] b2RayCastInput input);
    static void makePolygon([Const] b2Hull hull, float radius, [Ref] b2Polygon result);
    static void makeOffsetPolygon([Const] b2Hull hull, [Ref] b2Vec2 position, [Ref] b2Rot rotation, [Ref] b2Polygon result);
    static void makeOffsetRoundedPolygon([Const] b2Hull hull, [Ref] b2Vec2 position, [Ref] b2Rot rotation, float radius, [Ref] b2Polygon result);
    static void makeSquare(float halfWidth, [Ref] b2Polygon result);
    static void makeBox(float halfWidth, float halfHeight, [Ref] b2Polygon result);
    static void makeRoundedBox(float halfWidth, float halfHeight, float radius, [Ref] b2Polygon result);
    static void makeOffsetBox(float halfWidth, float halfHeight, [Ref] b2Vec2 center, [Ref] b2Rot rotation, [Ref] b2Polygon result);
    static void makeOffsetRoundedBox(float halfWidth, float halfHeight, [Ref] b2Vec2 center, [Ref] b2Rot rotation, float radius, [Ref] b2Polygon result);
    static void transformPolygon([Ref] b2Transform transform, [Const] b2Polygon polygon, [Ref] b2Polygon result);
    [Value] static b2MassData computeCircleMass([Const] b2Circle shape, float density);
    [Value] static b2MassData computeCapsuleMass([Const] b2Capsule shape, float density);
    [Value] static b2MassData computePolygonMass([Const] b2Polygon shape, float density);
    [Value] static b2AABB computeCircleAABB([Const] b2Circle shape, [Ref] b2Transform transform);
    [Value] static b2AABB computeCapsuleAABB([Const] b2Capsule shape, [Ref] b2Transform transform);
    [Value] static b2AABB computePolygonAABB([Const] b2Polygon shape, [Ref] b2Transform transform);
    [Value] static b2AABB computeSegmentAABB([Const] b2Segment shape, [Ref] b2Transform transform);
    static boolean pointInCircle([Ref] b2Vec2 point, [Const] b2Circle shape);
    static boolean pointInCapsule([Ref] b2Vec2 point, [Const] b2Capsule shape);
    static boolean pointInPolygon([Ref] b2Vec2 point, [Const] b2Polygon shape);
    [Value] static b2CastOutput rayCastCircle([Const] b2RayCastInput input, [Const] b2Circle shape);
    [Value] static b2CastOutput rayCastCapsule([Const] b2RayCastInput input, [Const] b2Capsule shape);
    [Value] static b2CastOutput rayCastSegment([Const] b2RayCastInput input, [Const] b2Segment shape, boolean oneSided);
    [Value] static b2CastOutput rayCastPolygon([Const] b2RayCastInput input, [Const] b2Polygon shape);
    [Value] static b2CastOutput shapeCastCircle([Const] b2ShapeCastInput input, [Const] b2Circle shape);
    [Value] static b2CastOutput shapeCastCapsule([Const] b2ShapeCastInput input, [Const] b2Capsule shape);
    [Value] static b2CastOutput shapeCastSegment([Const] b2ShapeCastInput input, [Const] b2Segment shape);
    [Value] static b2CastOutput shapeCastPolygon([Const] b2ShapeCastInput input, [Const] b2Polygon shape);
    static void computeHull(b2Vec2Array points, [Ref] b2Hull result);
    static boolean validateHull([Const] b2Hull hull);
    static readonly attribute unsigned long MAX_POLYGON_VERTICES;
};

[NoDelete]
interface B2_Joint {
    static void destroyJoint(unsigned long long jointId);
    static boolean isValid(unsigned long long jointId);
    static b2JointType getType(unsigned long long jointId);
    static unsigned long long getBodyA(unsigned long long jointId);
    static unsigned long long getBodyB(unsigned long long jointId);
    static unsigned long getWorld(unsigned long long jointId);
    [Value] static b2Vec2 getLocalAnchorA(unsigned long long jointId);
    [Value] static b2Vec2 getLocalAnchorB(unsigned long long jointId);
    static void setLocalAnchorA(unsigned long long jointId, [Ref] b2Vec2 localAnchor);
    static void setLocalAnchorB(unsigned long long jointId, [Ref] b2Vec2 localAnchor);
    static float getReferenceAngle(unsigned long long jointId);
    static void setReferenceAngle(unsigned long long jointId, float angleInRadians);
    static void setLocalAxisA(unsigned long long jointId, [Ref] b2Vec2 localAxis);
    [Value] static b2Vec2 getLocalAxisA(unsigned long long jointId);
    static void setCollideConnected(unsigned long long jointId, boolean shouldCollide);
    static boolean getCollideConnected(unsigned long long jointId);
    static void setUserData(unsigned long long jointId, any userData);
    static any getUserData(unsigned long long jointId);
    static void wakeBodies(unsigned long long jointId);
    [Value] static b2Vec2 getConstraintForce(unsigned long long jointId);
    static float getConstraintTorque(unsigned long long jointId);
    static float getLinearSeparation(unsigned long long jointId);
    static float getAngularSeparation(unsigned long long jointId);
    static float getConstraintTuningHertz(unsigned long long jointId);
    static float getConstraintTuningDampingRatio(unsigned long long jointId);
    static void setConstraintTuning(unsigned long long jointId, float hertz, float dampingRatio);
};

[NoDelete]
interface B2_Mat22 {
    static void mulMV([Ref] b2Mat22 A, [Ref] b2Vec2 v, [Ref] b2Vec2 result);
    static void getInverse22([Ref] b2Mat22 A, [Ref] b2Mat22 result);
    static void solve22([Ref] b2Mat22 A, [Ref] b2Vec2 b, [Ref] b2Vec2 result);
};

[NoDelete]
interface B2_Math {
    static void computeCosSin(float radians, [Ref] b2CosSin result);
    static float springDamper(float hertz, float dampingRatio, float position, float velocity, float timeStep);
    static void setLengthUnitsPerMeter(float lengthUnits);
    static float getLengthUnitsPerMeter();
};

[NoDelete]
interface B2_MotorJoint {
    static unsigned long long createMotorJoint(unsigned long long worldId, [Const] b2MotorJointDef def);
    static void defaultMotorJointDef([Ref] b2MotorJointDef result);
    static void setLinearOffset(unsigned long long jointId, [Ref] b2Vec2 linearOffset);
    [Value] static b2Vec2 getLinearOffset(unsigned long long jointId);
    static void setAngularOffset(unsigned long long jointId, float angularOffset);
    static float getAngularOffset(unsigned long long jointId);
    static void setMaxForce(unsigned long long jointId, float maxForce);
    static float getMaxForce(unsigned long long jointId);
    static void setMaxTorque(unsigned long long jointId, float maxTorque);
    static float getMaxTorque(unsigned long long jointId);
    static void setCorrectionFactor(unsigned long long jointId, float correctionFactor);
    static float getCorrectionFactor(unsigned long long jointId);
};

[NoDelete]
interface B2_MouseJoint {
    static unsigned long long createMouseJoint(unsigned long long worldId, [Const] b2MouseJointDef def);
    static void defaultMouseJointDef([Ref] b2MouseJointDef result);
    static void setTarget(unsigned long long jointId, [Ref] b2Vec2 target);
    [Value] static b2Vec2 getTarget(unsigned long long jointId);
    static void setSpringHertz(unsigned long long jointId, float hertz);
    static float getSpringHertz(unsigned long long jointId);
    static void setSpringDampingRatio(unsigned long long jointId, float dampingRatio);
    static float getSpringDampingRatio(unsigned long long jointId);
    static void setMaxForce(unsigned long long jointId, float maxForce);
    static float getMaxForce(unsigned long long jointId);
};

[NoDelete]
interface B2_Plane {
    static float planeSeparation([Ref] b2Plane plane, [Ref] b2Vec2 point);
    static boolean isValid([Ref] b2Plane plane);
};

[NoDelete]
interface B2_PrismaticJoint {
    static unsigned long long createPrismaticJoint(unsigned long long worldId, [Const] b2PrismaticJointDef def);
    static void defaultPrismaticJointDef([Ref] b2PrismaticJointDef result);
    static void enableSpring(unsigned long long jointId, boolean enableSpring);
    static boolean isSpringEnabled(unsigned long long jointId);
    static void setSpringHertz(unsigned long long jointId, float hertz);
    static float getSpringHertz(unsigned long long jointId);
    static void setSpringDampingRatio(unsigned long long jointId, float dampingRatio);
    static float getSpringDampingRatio(unsigned long long jointId);
    static void setTargetTranslation(unsigned long long jointId, float translation);
    static float getTargetTranslation(unsigned long long jointId);
    static void enableLimit(unsigned long long jointId, boolean enableLimit);
    static boolean isLimitEnabled(unsigned long long jointId);
    static float getLowerLimit(unsigned long long jointId);
    static float getUpperLimit(unsigned long long jointId);
    static void setLimits(unsigned long long jointId, float lower, float upper);
    static void enableMotor(unsigned long long jointId, boolean enableMotor);
    static boolean isMotorEnabled(unsigned long long jointId);
    static void setMotorSpeed(unsigned long long jointId, float motorSpeed);
    static float getMotorSpeed(unsigned long long jointId);
    static void setMaxMotorForce(unsigned long long jointId, float force);
    static float getMaxMotorForce(unsigned long long jointId);
    static float getMotorForce(unsigned long long jointId);
    static float getTranslation(unsigned long long jointId);
    static float getSpeed(unsigned long long jointId);
};

[NoDelete]
interface B2_RevoluteJoint {
    static unsigned long long createRevoluteJoint(unsigned long long worldId, [Const] b2RevoluteJointDef def);
    static void defaultRevoluteJointDef([Ref] b2RevoluteJointDef result);
    static void enableSpring(unsigned long long jointId, boolean enableSpring);
    static boolean isSpringEnabled(unsigned long long jointId);
    static void setSpringHertz(unsigned long long jointId, float hertz);
    static float getSpringHertz(unsigned long long jointId);
    static void setSpringDampingRatio(unsigned long long jointId, float dampingRatio);
    static float getSpringDampingRatio(unsigned long long jointId);
    static void setTargetAngle(unsigned long long jointId, float angle);
    static float getTargetAngle(unsigned long long jointId);
    static float getAngle(unsigned long long jointId);
    static void enableLimit(unsigned long long jointId, boolean enableLimit);
    static boolean isLimitEnabled(unsigned long long jointId);
    static float getLowerLimit(unsigned long long jointId);
    static float getUpperLimit(unsigned long long jointId);
    static void setLimits(unsigned long long jointId, float lower, float upper);
    static void enableMotor(unsigned long long jointId, boolean enableMotor);
    static boolean isMotorEnabled(unsigned long long jointId);
    static void setMotorSpeed(unsigned long long jointId, float motorSpeed);
    static float getMotorSpeed(unsigned long long jointId);
    static float getMotorTorque(unsigned long long jointId);
    static void setMaxMotorTorque(unsigned long long jointId, float torque);
    static float getMaxMotorTorque(unsigned long long jointId);
};

[NoDelete]
interface B2_Rot {
    static float getAngle([Ref] b2Rot q);
    static void getXAxis([Ref] b2Rot q, [Ref] b2Vec2 result);
    static void getYAxis([Ref] b2Rot q, [Ref] b2Vec2 result);
    static void makeRot(float radians, [Ref] b2Rot result);
    static void normalize([Ref] b2Rot q, [Ref] b2Rot result);
    static boolean isNormalized([Ref] b2Rot q);
    static void integrateRotation([Ref] b2Rot q1, float deltaAngle, [Ref] b2Rot result);
    static void nLerp([Ref] b2Rot q1, [Ref] b2Rot q2, float t, [Ref] b2Rot result);
    static void mulRot([Ref] b2Rot q, [Ref] b2Rot r, [Ref] b2Rot result);
    static void invMulRot([Ref] b2Rot q, [Ref] b2Rot r, [Ref] b2Rot result);
    static float relativeAngle([Ref] b2Rot b, [Ref] b2Rot a);
    static float unwindAngle(float radians);
    static void rotateVector([Ref] b2Rot q, [Ref] b2Vec2 v, [Ref] b2Vec2 result);
    static void invRotateVector([Ref] b2Rot q, [Ref] b2Vec2 v, [Ref] b2Vec2 result);
    static float computeAngularVelocity([Ref] b2Rot q1, [Ref] b2Rot q2, float inv_h);
    static void computeRotationBetweenUnitVectors([Ref] b2Vec2 v1, [Ref] b2Vec2 v2, [Ref] b2Rot result);
    static boolean isValid([Ref] b2Rot q);
};

[NoDelete]
interface B2_Shape {
    static void defaultShapeDef([Ref] b2ShapeDef result);
    static unsigned long long createCircleShape(unsigned long long bodyId, [Const] b2ShapeDef def, [Const] b2Circle circle);
    static unsigned long long createSegmentShape(unsigned long long bodyId, [Const] b2ShapeDef def, [Const] b2Segment segment);
    static unsigned long long createCapsuleShape(unsigned long long bodyId, [Const] b2ShapeDef def, [Const] b2Capsule capsule);
    static unsigned long long createPolygonShape(unsigned long long bodyId, [Const] b2ShapeDef def, [Const] b2Polygon polygon);
    static void destroyShape(unsigned long long shapeId, boolean updateBodyMass);
    static boolean isValid(unsigned long long id);
    static b2ShapeType getType(unsigned long long shapeId);
    static unsigned long long getBody(unsigned long long shapeId);
    [Value] static b2WorldId getWorld(unsigned long long shapeId);
    static boolean isSensor(unsigned long long shapeId);
    static void setUserData(unsigned long long shapeId, VoidPtr userData);
    static VoidPtr getUserData(unsigned long long shapeId);
    static void setDensity(unsigned long long shapeId, float density, boolean updateBodyMass);
    static float getDensity(unsigned long long shapeId);
    static void setFriction(unsigned long long shapeId, float friction);
    static float getFriction(unsigned long long shapeId);
    static void setRestitution(unsigned long long shapeId, float restitution);
    static float getRestitution(unsigned long long shapeId);
    static void setMaterial(unsigned long long shapeId, long material);
    static long getMaterial(unsigned long long shapeId);
    static void setSurfaceMaterial(unsigned long long shapeId, [Ref] b2SurfaceMaterial surfaceMaterial);
    [Value] static b2SurfaceMaterial getSurfaceMaterial(unsigned long long shapeId);
    [Value] static b2Filter getFilter(unsigned long long shapeId);
    static void setFilter(unsigned long long shapeId, [Ref] b2Filter filter);
    static void enableSensorEvents(unsigned long long shapeId, boolean flag);
    static boolean areSensorEventsEnabled(unsigned long long shapeId);
    static void enableContactEvents(unsigned long long shapeId, boolean flag);
    static boolean areContactEventsEnabled(unsigned long long shapeId);
    static void enablePreSolveEvents(unsigned long long shapeId, boolean flag);
    static boolean arePreSolveEventsEnabled(unsigned long long shapeId);
    static void enableHitEvents(unsigned long long shapeId, boolean flag);
    static boolean areHitEventsEnabled(unsigned long long shapeId);
    static boolean testPoint(unsigned long long shapeId, [Ref] b2Vec2 point);
    [Value] static b2CastOutput rayCast(unsigned long long shapeId, [Const] b2RayCastInput input);
    [Value] static b2Circle getCircle(unsigned long long shapeId);
    [Value] static b2Segment getSegment(unsigned long long shapeId);
    [Value] static b2ChainSegment getChainSegment(unsigned long long shapeId);
    [Value] static b2Capsule getCapsule(unsigned long long shapeId);
    [Value] static b2Polygon getPolygon(unsigned long long shapeId);
    static void setCircle(unsigned long long shapeId, [Const] b2Circle circle);
    static void setCapsule(unsigned long long shapeId, [Const] b2Capsule capsule);
    static void setSegment(unsigned long long shapeId, [Const] b2Segment segment);
    static void setPolygon(unsigned long long shapeId, [Const] b2Polygon polygon);
    static unsigned long long getParentChain(unsigned long long shapeId);
    static long getContactCapacity(unsigned long long shapeId);
    static long getContactData(unsigned long long shapeId, b2ContactDataArray contactData);
    static long getSensorCapacity(unsigned long long shapeId);
    static long getSensorOverlaps(unsigned long long shapeId, b2ShapeIdArray overlaps);
    [Value] static b2AABB getAABB(unsigned long long shapeId);
    [Value] static b2MassData getMassData(unsigned long long shapeId);
    [Value] static b2Vec2 getClosestPoint(unsigned long long shapeId, [Ref] b2Vec2 target);
};

[NoDelete]
interface B2_Transform {
    static void transformPoint([Ref] b2Transform t, [Ref] b2Vec2 p, [Ref] b2Vec2 result);
    static void invTransformPoint([Ref] b2Transform t, [Ref] b2Vec2 p, [Ref] b2Vec2 result);
    static void mulTransforms([Ref] b2Transform A, [Ref] b2Transform B, [Ref] b2Transform result);
    static void invMulTransforms([Ref] b2Transform A, [Ref] b2Transform B, [Ref] b2Transform result);
};

[NoDelete]
interface B2_Vec2 {
    static float dot([Ref] b2Vec2 a, [Ref] b2Vec2 b);
    static float cross([Ref] b2Vec2 a, [Ref] b2Vec2 b);
    static void crossVS([Ref] b2Vec2 v, float s, [Ref] b2Vec2 result);
    static void crossSV(float s, [Ref] b2Vec2 v, [Ref] b2Vec2 result);
    static void leftPerp([Ref] b2Vec2 v, [Ref] b2Vec2 result);
    static void rightPerp([Ref] b2Vec2 v, [Ref] b2Vec2 result);
    static void add([Ref] b2Vec2 a, [Ref] b2Vec2 b, [Ref] b2Vec2 result);
    static void sub([Ref] b2Vec2 a, [Ref] b2Vec2 b, [Ref] b2Vec2 result);
    static void neg([Ref] b2Vec2 a, [Ref] b2Vec2 result);
    static void lerp([Ref] b2Vec2 a, [Ref] b2Vec2 b, float t, [Ref] b2Vec2 result);
    static void mul([Ref] b2Vec2 a, [Ref] b2Vec2 b, [Ref] b2Vec2 result);
    static void mulSV(float s, [Ref] b2Vec2 v, [Ref] b2Vec2 result);
    static void mulAdd([Ref] b2Vec2 a, float s, [Ref] b2Vec2 b, [Ref] b2Vec2 result);
    static void mulSub([Ref] b2Vec2 a, float s, [Ref] b2Vec2 b, [Ref] b2Vec2 result);
    static void abs([Ref] b2Vec2 a, [Ref] b2Vec2 result);
    static void min([Ref] b2Vec2 a, [Ref] b2Vec2 b, [Ref] b2Vec2 result);
    static void max([Ref] b2Vec2 a, [Ref] b2Vec2 b, [Ref] b2Vec2 result);
    static void clamp([Ref] b2Vec2 v, [Ref] b2Vec2 a, [Ref] b2Vec2 b, [Ref] b2Vec2 result);
    static float length([Ref] b2Vec2 v);
    static float distance([Ref] b2Vec2 a, [Ref] b2Vec2 b);
    static void normalize([Ref] b2Vec2 v, [Ref] b2Vec2 result);
    static boolean isNormalized([Ref] b2Vec2 a);
    static float getLengthAndNormalize([Ref] b2Vec2 v, [Ref] b2Vec2 result);
    static float lengthSquared([Ref] b2Vec2 v);
    static boolean isValid([Ref] b2Vec2 v);
};

[NoDelete]
interface B2_WeldJoint {
    static unsigned long long createWeldJoint(unsigned long long worldId, [Const] b2WeldJointDef def);
    static void defaultWeldJointDef([Ref] b2WeldJointDef result);
    static void setLinearHertz(unsigned long long jointId, float hertz);
    static float getLinearHertz(unsigned long long jointId);
    static void setLinearDampingRatio(unsigned long long jointId, float dampingRatio);
    static float getLinearDampingRatio(unsigned long long jointId);
    static void setAngularHertz(unsigned long long jointId, float hertz);
    static float getAngularHertz(unsigned long long jointId);
    static void setAngularDampingRatio(unsigned long long jointId, float dampingRatio);
    static float getAngularDampingRatio(unsigned long long jointId);
};

[NoDelete]
interface B2_WheelJoint {
    static unsigned long long createWheelJoint(unsigned long long worldId, [Const] b2WheelJointDef def);
    static void defaultWheelJointDef([Ref] b2WheelJointDef result);
    static void enableSpring(unsigned long long jointId, boolean enableSpring);
    static boolean isSpringEnabled(unsigned long long jointId);
    static void setSpringHertz(unsigned long long jointId, float hertz);
    static float getSpringHertz(unsigned long long jointId);
    static void setSpringDampingRatio(unsigned long long jointId, float dampingRatio);
    static float getSpringDampingRatio(unsigned long long jointId);
    static void enableLimit(unsigned long long jointId, boolean enableLimit);
    static boolean isLimitEnabled(unsigned long long jointId);
    static float getLowerLimit(unsigned long long jointId);
    static float getUpperLimit(unsigned long long jointId);
    static void setLimits(unsigned long long jointId, float lower, float upper);
    static void enableMotor(unsigned long long jointId, boolean enableMotor);
    static boolean isMotorEnabled(unsigned long long jointId);
    static void setMotorSpeed(unsigned long long jointId, float motorSpeed);
    static float getMotorSpeed(unsigned long long jointId);
    static void setMaxMotorTorque(unsigned long long jointId, float torque);
    static float getMaxMotorTorque(unsigned long long jointId);
    static float getMotorTorque(unsigned long long jointId);
};

[NoDelete]
interface B2_World {
    static void defaultWorldDef([Ref] b2WorldDef result);
    static unsigned long long createWorld([Const] b2WorldDef def);
    static void destroyWorld(unsigned long long worldId);
    static boolean isValid(unsigned long long worldId);
    static void step(unsigned long long worldId, float timeStep, long subStepCount);
    static void draw(unsigned long long worldId, b2DebugDraw draw, b2DebugDrawCallbacks callbacks);
    [Value] static b2BodyEvents getBodyEvents(unsigned long long worldId);
    [Value] static b2SensorEvents getSensorEvents(unsigned long long worldId);
    [Value] static b2ContactEvents getContactEvents(unsigned long long worldId);
    [Value] static b2TreeStats overlapAABB(unsigned long long worldId, [Ref] b2AABB aabb, [Ref] b2QueryFilter filter, b2OverlapResultFcnI fcn);
    [Value] static b2TreeStats overlapShape(unsigned long long worldId, [Const] b2ShapeProxy proxy, [Ref] b2QueryFilter filter, b2OverlapResultFcnI fcn);
    [Value] static b2TreeStats castRay(unsigned long long worldId, [Ref] b2Vec2 origin, [Ref] b2Vec2 translation, [Ref] b2QueryFilter filter, b2CastResultFcnI fcn);
    [Value] static b2RayResult castRayClosest(unsigned long long worldId, [Ref] b2Vec2 origin, [Ref] b2Vec2 translation, [Ref] b2QueryFilter filter);
    [Value] static b2TreeStats castShape(unsigned long long worldId, [Const] b2ShapeProxy proxy, [Ref] b2Vec2 translation, [Ref] b2QueryFilter filter, b2CastResultFcnI fcn);
    static float castMover(unsigned long long worldId, [Const] b2Capsule mover, [Ref] b2Vec2 translation, [Ref] b2QueryFilter filter);
    static void collideMover(unsigned long long worldId, [Const] b2Capsule mover, [Ref] b2QueryFilter filter, b2PlaneResultFcnI fcn);
    static void enableSleeping(unsigned long long worldId, boolean flag);
    static boolean isSleepingEnabled(unsigned long long worldId);
    static void enableContinuous(unsigned long long worldId, boolean flag);
    static boolean isContinuousEnabled(unsigned long long worldId);
    static void setRestitutionThreshold(unsigned long long worldId, float value);
    static float getRestitutionThreshold(unsigned long long worldId);
    static void setHitEventThreshold(unsigned long long worldId, float value);
    static float getHitEventThreshold(unsigned long long worldId);
    static void setGravity(unsigned long long worldId, [Ref] b2Vec2 gravity);
    [Value] static b2Vec2 getGravity(unsigned long long worldId);
    static void setCustomFilterCallback(unsigned long long worldId, b2CustomFilterFcnI fcn);
    static void setPreSolveCallback(unsigned long long worldId, b2PreSolveFcnI fcn);
    static void setFrictionCallback(unsigned long long worldId, b2FrictionCallbackI callback);
    static void setRestitutionCallback(unsigned long long worldId, b2RestitutionCallbackI callback);
    static void explode(unsigned long long worldId, [Const] b2ExplosionDef explosionDef);
    static void setContactTuning(unsigned long long worldId, float hertz, float dampingRatio, float pushSpeed);
    static void setMaximumLinearSpeed(unsigned long long worldId, float maximumLinearSpeed);
    static float getMaximumLinearSpeed(unsigned long long worldId);
    static void enableWarmStarting(unsigned long long worldId, boolean flag);
    static boolean isWarmStartingEnabled(unsigned long long worldId);
    static long getAwakeBodyCount(unsigned long long worldId);
    [Value] static b2Profile getProfile(unsigned long long worldId);
    [Value] static b2Counters getCounters(unsigned long long worldId);
    static void dumpMemoryStats(unsigned long long worldId);
    static void setUserData(unsigned long long worldId, VoidPtr userData);
    static VoidPtr getUserData(unsigned long long worldId);
    static void rebuildStaticTree(unsigned long long worldId);
    static void enableSpeculative(unsigned long long worldId, boolean flag);
};

interface TaskManager {
    void install([Ref] b2WorldDef worldDef, long threadCount);
    void executeTask(unsigned long start, unsigned long end, unsigned long threadIndex, unsigned long long box2dTask, unsigned long long box2dContext);
};

[JSImplementation="TaskManager"]
interface TaskManagerImpl {
    void TaskManagerImpl();
    unsigned long long enqueueTask(unsigned long long box2dTask, long itemCount, long minRange, unsigned long long box2dContext);
    void finishTask(unsigned long long userTask);
};

interface b2AABB {
    void b2AABB();
    [Value] attribute b2Vec2 lowerBound;
    [Value] attribute b2Vec2 upperBound;
};

interface b2BodyDef {
    void b2BodyDef();
    attribute b2BodyType type;
    [Value] attribute b2Vec2 position;
    [Value] attribute b2Rot rotation;
    [Value] attribute b2Vec2 linearVelocity;
    attribute float angularVelocity;
    attribute float linearDamping;
    attribute float angularDamping;
    attribute float gravityScale;
    attribute float sleepThreshold;
    [Const] attribute DOMString name;
    attribute VoidPtr userData;
    attribute boolean enableSleep;
    attribute boolean isAwake;
    attribute boolean fixedRotation;
    attribute boolean isBullet;
    attribute boolean isEnabled;
    attribute boolean allowFastRotation;
};

interface b2BodyEvents {
    void b2BodyEvents();
    attribute long moveCount;
    attribute b2BodyMoveEvent moveEvents;
};

interface b2BodyId {
    void b2BodyId();
    attribute unsigned short generation;
    attribute long index1;
    attribute unsigned short world0;
};

interface b2BodyMoveEvent {
    void b2BodyMoveEvent();
    [Value] attribute b2BodyId bodyId;
    attribute boolean fellAsleep;
    [Value] attribute b2Transform transform;
    attribute VoidPtr userData;
};

interface b2Capsule {
    void b2Capsule();
    [Value] attribute b2Vec2 center1;
    [Value] attribute b2Vec2 center2;
    attribute float radius;
};

interface b2CastOutput {
    void b2CastOutput();
    attribute float fraction;
    attribute boolean hit;
    attribute long iterations;
    [Value] attribute b2Vec2 normal;
    [Value] attribute b2Vec2 point;
};

interface b2CastResultFcnI {
};

[JSImplementation="b2CastResultFcnI"]
interface b2CastResultFcnImpl {
    void b2CastResultFcnImpl();
    boolean castResultFcn(unsigned long long shapeId, [Ref] b2Vec2 point, [Ref] b2Vec2 normal, float fraction);
};

interface b2ChainDef {
    void b2ChainDef();
    attribute VoidPtr userData;
    [Const] attribute b2Vec2 points;
    attribute long count;
    [Const] attribute b2SurfaceMaterial materials;
    attribute long materialCount;
    [Value] attribute b2Filter filter;
    attribute boolean isLoop;
    attribute boolean enableSensorEvents;
    attribute long internalValue;
};

interface b2ChainId {
    void b2ChainId();
    attribute unsigned short generation;
    attribute long index1;
    attribute unsigned short world0;
};

interface b2ChainSegment {
    void b2ChainSegment();
    attribute long chainId;
    [Value] attribute b2Vec2 ghost1;
    [Value] attribute b2Vec2 ghost2;
    [Value] attribute b2Segment segment;
};

interface b2Circle {
    void b2Circle();
    [Value] attribute b2Vec2 center;
    attribute float radius;
};

interface b2CollisionPlane {
    void b2CollisionPlane();
    attribute boolean clipVelocity;
    [Value] attribute b2Plane plane;
    attribute float push;
    attribute float pushLimit;
};

interface b2CollisionPlaneArray {
    void b2CollisionPlaneArray(unsigned long length);
    void set(unsigned long index, [Ref] b2CollisionPlane value);
    b2CollisionPlane get(unsigned long index);
    attribute unsigned long length;
};

interface b2ContactBeginTouchEvent {
    void b2ContactBeginTouchEvent();
    [Value] attribute b2Manifold manifold;
    [Value] attribute b2ShapeId shapeIdA;
    [Value] attribute b2ShapeId shapeIdB;
};

interface b2ContactData {
    void b2ContactData();
    [Value] attribute b2Manifold manifold;
    [Value] attribute b2ShapeId shapeIdA;
    [Value] attribute b2ShapeId shapeIdB;
};

interface b2ContactDataArray {
    void b2ContactDataArray(unsigned long length);
    void set(unsigned long index, [Ref] b2ContactData value);
    b2ContactData get(unsigned long index);
    attribute unsigned long length;
};

interface b2ContactEndTouchEvent {
    void b2ContactEndTouchEvent();
    [Value] attribute b2ShapeId shapeIdA;
    [Value] attribute b2ShapeId shapeIdB;
};

interface b2ContactEvents {
    void b2ContactEvents();
    attribute long beginCount;
    attribute b2ContactBeginTouchEvent beginEvents;
    attribute long endCount;
    attribute b2ContactEndTouchEvent endEvents;
    attribute long hitCount;
    attribute b2ContactHitEvent hitEvents;
};

interface b2ContactHitEvent {
    void b2ContactHitEvent();
    attribute float approachSpeed;
    [Value] attribute b2Vec2 normal;
    [Value] attribute b2Vec2 point;
    [Value] attribute b2ShapeId shapeIdA;
    [Value] attribute b2ShapeId shapeIdB;
};

interface b2CosSin {
    void b2CosSin();
    attribute float cosine;
    attribute float sine;
};

interface b2Counters {
    void b2Counters();
    attribute long bodyCount;
    attribute long shapeCount;
    attribute long contactCount;
    attribute long jointCount;
    attribute long islandCount;
    attribute long stackUsed;
    attribute long staticTreeHeight;
    attribute long treeHeight;
    attribute long byteCount;
    attribute long taskCount;
    attribute long[] colorCounts;
};

interface b2CustomFilterFcnI {
};

[JSImplementation="b2CustomFilterFcnI"]
interface b2CustomFilterFcnImpl {
    void b2CustomFilterFcnImpl();
    boolean customFilterFcn(unsigned long long shapeIdA, unsigned long long shapeIdB);
};

interface b2DebugDraw {
    void b2DebugDraw();
    [Value] attribute b2AABB drawingBounds;
    attribute boolean useDrawingBounds;
    attribute boolean drawShapes;
    attribute boolean drawJoints;
    attribute boolean drawJointExtras;
    attribute boolean drawBounds;
    attribute boolean drawMass;
    attribute boolean drawBodyNames;
    attribute boolean drawContacts;
    attribute boolean drawGraphColors;
    attribute boolean drawContactNormals;
    attribute boolean drawContactImpulses;
    attribute boolean drawContactFeatures;
    attribute boolean drawFrictionImpulses;
    attribute boolean drawIslands;
};

interface b2DebugDrawCallbacks {
};

[JSImplementation="b2DebugDrawCallbacks"]
interface b2DebugDrawCallbacksImpl {
    void b2DebugDrawCallbacksImpl();
    void drawPolygon([Const] b2Vec2 vertices, long vertexCount, long color);
    void drawSolidPolygon([Ref] b2Transform transform, [Const] b2Vec2 vertices, long vertexCount, float radius, long color);
    void drawCircle([Ref] b2Vec2 center, float radius, long color);
    void drawSolidCircle([Ref] b2Transform transform, float radius, long color);
    void drawSolidCapsule([Ref] b2Vec2 p1, [Ref] b2Vec2 p2, float radius, long color);
    void drawSegment([Ref] b2Vec2 p1, [Ref] b2Vec2 p2, long color);
    void drawTransform([Ref] b2Transform transform);
    void drawPoint([Ref] b2Vec2 p, float size, long color);
    void drawString([Ref] b2Vec2 p, [Const] DOMString s, long color);
};

interface b2DistanceInput {
    void b2DistanceInput();
    [Value] attribute b2ShapeProxy proxyA;
    [Value] attribute b2ShapeProxy proxyB;
    [Value] attribute b2Transform transformA;
    [Value] attribute b2Transform transformB;
    attribute boolean useRadii;
};

interface b2DistanceJointDef {
    void b2DistanceJointDef();
    [Value] attribute b2BodyId bodyIdA;
    [Value] attribute b2BodyId bodyIdB;
    attribute boolean collideConnected;
    attribute float dampingRatio;
    attribute boolean enableLimit;
    attribute boolean enableMotor;
    attribute boolean enableSpring;
    attribute float hertz;
    attribute long internalValue;
    attribute float length;
    [Value] attribute b2Vec2 localAnchorA;
    [Value] attribute b2Vec2 localAnchorB;
    attribute float maxLength;
    attribute float maxMotorForce;
    attribute float minLength;
    attribute float motorSpeed;
    attribute VoidPtr userData;
};

interface b2DistanceOutput {
    void b2DistanceOutput();
    [Value] attribute b2Vec2 pointA;
    [Value] attribute b2Vec2 pointB;
    [Value] attribute b2Vec2 normal;
    attribute float distance;
    attribute long iterations;
    attribute long simplexCount;
};

interface b2ExplosionDef {
    void b2ExplosionDef();
    attribute float falloff;
    attribute float impulsePerLength;
    attribute unsigned long long maskBits;
    [Value] attribute b2Vec2 position;
    attribute float radius;
};

interface b2Filter {
    void b2Filter();
    attribute unsigned long long categoryBits;
    attribute long groupIndex;
    attribute unsigned long long maskBits;
};

interface b2FilterJointDef {
    void b2FilterJointDef();
    [Value] attribute b2BodyId bodyIdA;
    [Value] attribute b2BodyId bodyIdB;
    attribute VoidPtr userData;
};

interface b2FrictionCallbackI {
};

[JSImplementation="b2FrictionCallbackI"]
interface b2FrictionCallbackImpl {
    void b2FrictionCallbackImpl();
    float frictionCallback(float frictionA, long userMaterialIdA, float frictionB, long userMaterialIdB);
};

interface b2Hull {
    void b2Hull();
    attribute long count;
    [Value] attribute b2Vec2[] points;
};

interface b2JointId {
    void b2JointId();
    attribute unsigned short generation;
    attribute long index1;
    attribute unsigned short world0;
};

interface b2JointIdArray {
    void b2JointIdArray(unsigned long length);
    void set(unsigned long index, [Ref] b2JointId value);
    b2JointId get(unsigned long index);
    attribute unsigned long length;
};

interface b2Manifold {
    void b2Manifold();
    [Value] attribute b2Vec2 normal;
    attribute long pointCount;
    [Value] attribute b2ManifoldPoint[] points;
    attribute float rollingImpulse;
};

interface b2ManifoldPoint {
    void b2ManifoldPoint();
    [Value] attribute b2Vec2 anchorA;
    [Value] attribute b2Vec2 anchorB;
    attribute unsigned short id;
    attribute float normalImpulse;
    attribute float normalVelocity;
    attribute boolean persisted;
    [Value] attribute b2Vec2 point;
    attribute float separation;
    attribute float tangentImpulse;
    attribute float totalNormalImpulse;
};

interface b2MassData {
    void b2MassData();
    [Value] attribute b2Vec2 center;
    attribute float mass;
    attribute float rotationalInertia;
};

interface b2Mat22 {
    void b2Mat22();
    [Value] attribute b2Vec2 cx;
    [Value] attribute b2Vec2 cy;
};

interface b2MotorJointDef {
    void b2MotorJointDef();
    attribute float angularOffset;
    [Value] attribute b2BodyId bodyIdA;
    [Value] attribute b2BodyId bodyIdB;
    attribute boolean collideConnected;
    attribute float correctionFactor;
    attribute long internalValue;
    [Value] attribute b2Vec2 linearOffset;
    attribute float maxForce;
    attribute float maxTorque;
    attribute VoidPtr userData;
};

interface b2MouseJointDef {
    void b2MouseJointDef();
    [Value] attribute b2BodyId bodyIdA;
    [Value] attribute b2BodyId bodyIdB;
    attribute boolean collideConnected;
    attribute float dampingRatio;
    attribute float hertz;
    attribute long internalValue;
    attribute float maxForce;
    [Value] attribute b2Vec2 target;
    attribute VoidPtr userData;
};

interface b2OverlapResultFcnI {
};

[JSImplementation="b2OverlapResultFcnI"]
interface b2OverlapResultFcnImpl {
    void b2OverlapResultFcnImpl();
    boolean overlapResultFcn(unsigned long long shapeId);
};

interface b2Plane {
    void b2Plane();
    [Value] attribute b2Vec2 normal;
    attribute float offset;
};

interface b2PlaneResult {
    void b2PlaneResult();
    attribute boolean hit;
    [Value] attribute b2Plane plane;
};

interface b2PlaneResultFcnI {
};

[JSImplementation="b2PlaneResultFcnI"]
interface b2PlaneResultFcnImpl {
    void b2PlaneResultFcnImpl();
    boolean planeResultFcn(unsigned long long shapeId, [Const] b2PlaneResult plane);
};

interface b2PlaneSolverResult {
    void b2PlaneSolverResult();
    attribute long iterationCount;
    [Value] attribute b2Vec2 translation;
};

interface b2Polygon {
    void b2Polygon();
    [Value] attribute b2Vec2[] vertices;
    [Value] attribute b2Vec2[] normals;
    [Value] attribute b2Vec2 centroid;
    attribute float radius;
    attribute long count;
};

interface b2PreSolveFcnI {
};

[JSImplementation="b2PreSolveFcnI"]
interface b2PreSolveFcnImpl {
    void b2PreSolveFcnImpl();
    boolean preSolveFcn(unsigned long long shapeIdA, unsigned long long shapeIdB, b2Manifold manifold);
};

interface b2PrismaticJointDef {
    void b2PrismaticJointDef();
    [Value] attribute b2BodyId bodyIdA;
    [Value] attribute b2BodyId bodyIdB;
    attribute boolean collideConnected;
    attribute float dampingRatio;
    attribute boolean enableLimit;
    attribute boolean enableMotor;
    attribute boolean enableSpring;
    attribute float hertz;
    attribute long internalValue;
    [Value] attribute b2Vec2 localAnchorA;
    [Value] attribute b2Vec2 localAnchorB;
    [Value] attribute b2Vec2 localAxisA;
    attribute float lowerTranslation;
    attribute float maxMotorForce;
    attribute float motorSpeed;
    attribute float referenceAngle;
    attribute float upperTranslation;
    attribute VoidPtr userData;
};

interface b2Profile {
    void b2Profile();
    attribute float step;
    attribute float pairs;
    attribute float collide;
    attribute float solve;
    attribute float mergeIslands;
    attribute float prepareStages;
    attribute float solveConstraints;
    attribute float prepareConstraints;
    attribute float integrateVelocities;
    attribute float warmStart;
    attribute float solveImpulses;
    attribute float integratePositions;
    attribute float relaxImpulses;
    attribute float applyRestitution;
    attribute float storeImpulses;
    attribute float splitIslands;
    attribute float transforms;
    attribute float hitEvents;
    attribute float refit;
    attribute float bullets;
    attribute float sleepIslands;
    attribute float sensors;
};

interface b2QueryFilter {
    void b2QueryFilter();
    attribute unsigned long long categoryBits;
    attribute unsigned long long maskBits;
};

interface b2RayCastInput {
    void b2RayCastInput();
    attribute float maxFraction;
    [Value] attribute b2Vec2 origin;
    [Value] attribute b2Vec2 translation;
};

interface b2RayResult {
    void b2RayResult();
    attribute float fraction;
    attribute boolean hit;
    attribute long leafVisits;
    attribute long nodeVisits;
    [Value] attribute b2Vec2 normal;
    [Value] attribute b2Vec2 point;
    [Value] attribute b2ShapeId shapeId;
};

interface b2RestitutionCallbackI {
};

[JSImplementation="b2RestitutionCallbackI"]
interface b2RestitutionCallbackImpl {
    void b2RestitutionCallbackImpl();
    float restitutionCallback(float restitutionA, long userMaterialIdA, float restitutionB, long userMaterialIdB);
};

interface b2RevoluteJointDef {
    void b2RevoluteJointDef();
    [Value] attribute b2BodyId bodyIdA;
    [Value] attribute b2BodyId bodyIdB;
    attribute boolean collideConnected;
    attribute float dampingRatio;
    attribute float drawSize;
    attribute boolean enableLimit;
    attribute boolean enableMotor;
    attribute boolean enableSpring;
    attribute float hertz;
    attribute long internalValue;
    [Value] attribute b2Vec2 localAnchorA;
    [Value] attribute b2Vec2 localAnchorB;
    attribute float lowerAngle;
    attribute float maxMotorTorque;
    attribute float motorSpeed;
    attribute float referenceAngle;
    attribute float upperAngle;
    attribute VoidPtr userData;
};

interface b2Rot {
    void b2Rot();
    attribute float c;
    attribute float s;
};

interface b2Segment {
    void b2Segment();
    [Value] attribute b2Vec2 point1;
    [Value] attribute b2Vec2 point2;
};

interface b2SegmentDistanceResult {
    void b2SegmentDistanceResult();
    [Value] attribute b2Vec2 closest1;
    [Value] attribute b2Vec2 closest2;
    attribute float fraction1;
    attribute float fraction2;
    attribute float distanceSquared;
};

interface b2SensorBeginTouchEvent {
    void b2SensorBeginTouchEvent();
    [Value] attribute b2ShapeId sensorShapeId;
    [Value] attribute b2ShapeId visitorShapeId;
};

interface b2SensorEndTouchEvent {
    void b2SensorEndTouchEvent();
    [Value] attribute b2ShapeId sensorShapeId;
    [Value] attribute b2ShapeId visitorShapeId;
};

interface b2SensorEvents {
    void b2SensorEvents();
    attribute long beginCount;
    attribute b2SensorBeginTouchEvent beginEvents;
    attribute long endCount;
    attribute b2SensorEndTouchEvent endEvents;
};

interface b2ShapeCastInput {
    void b2ShapeCastInput();
    attribute boolean canEncroach;
    attribute float maxFraction;
    [Value] attribute b2ShapeProxy proxy;
    [Value] attribute b2Vec2 translation;
};

interface b2ShapeCastPairInput {
    void b2ShapeCastPairInput();
    [Value] attribute b2ShapeProxy proxyA;
    [Value] attribute b2ShapeProxy proxyB;
    [Value] attribute b2Transform transformA;
    [Value] attribute b2Transform transformB;
    [Value] attribute b2Vec2 translationB;
    attribute float maxFraction;
    attribute boolean canEncroach;
};

interface b2ShapeDef {
    void b2ShapeDef();
    attribute VoidPtr userData;
    [Value] attribute b2SurfaceMaterial material;
    attribute float density;
    [Value] attribute b2Filter filter;
    attribute boolean isSensor;
    attribute boolean enableSensorEvents;
    attribute boolean enableContactEvents;
    attribute boolean enableHitEvents;
    attribute boolean enablePreSolveEvents;
    attribute boolean invokeContactCreation;
    attribute boolean updateBodyMass;
};

interface b2ShapeId {
    void b2ShapeId();
    attribute unsigned short generation;
    attribute long index1;
    attribute unsigned short world0;
};

interface b2ShapeIdArray {
    void b2ShapeIdArray(unsigned long length);
    void set(unsigned long index, [Ref] b2ShapeId value);
    b2ShapeId get(unsigned long index);
    attribute unsigned long length;
};

interface b2ShapeProxy {
    void b2ShapeProxy();
    attribute long count;
    [Value] attribute b2Vec2[] points;
    attribute float radius;
};

interface b2Simplex {
    void b2Simplex();
    [Value] attribute b2SimplexVertex v1;
    [Value] attribute b2SimplexVertex v2;
    [Value] attribute b2SimplexVertex v3;
    attribute long count;
};

interface b2SimplexCache {
    void b2SimplexCache();
    attribute unsigned short count;
    attribute octet[] indexA;
    attribute octet[] indexB;
};

interface b2SimplexVertex {
    void b2SimplexVertex();
    [Value] attribute b2Vec2 wA;
    [Value] attribute b2Vec2 wB;
    [Value] attribute b2Vec2 w;
    attribute float a;
    attribute long indexA;
    attribute long indexB;
};

interface b2SurfaceMaterial {
    void b2SurfaceMaterial();
    attribute unsigned long customColor;
    attribute float friction;
    attribute float restitution;
    attribute float rollingResistance;
    attribute float tangentSpeed;
    attribute long userMaterialId;
};

interface b2Sweep {
    void b2Sweep();
    [Value] attribute b2Vec2 localCenter;
    [Value] attribute b2Vec2 c1;
    [Value] attribute b2Vec2 c2;
    [Value] attribute b2Rot q1;
    [Value] attribute b2Rot q2;
};

interface b2TOIInput {
    void b2TOIInput();
    [Value] attribute b2ShapeProxy proxyA;
    [Value] attribute b2ShapeProxy proxyB;
    [Value] attribute b2Sweep sweepA;
    [Value] attribute b2Sweep sweepB;
    attribute float maxFraction;
};

interface b2TOIOutput {
    void b2TOIOutput();
    attribute b2TOIState state;
    attribute float fraction;
};

interface b2Transform {
    void b2Transform();
    [Value] attribute b2Vec2 p;
    [Value] attribute b2Rot q;
};

interface b2TreeStats {
    void b2TreeStats();
    attribute long leafVisits;
    attribute long nodeVisits;
};

interface b2Vec2 {
    void b2Vec2();
    attribute float x;
    attribute float y;
};

interface b2Vec2Array {
    void b2Vec2Array(unsigned long length);
    void set(unsigned long index, [Ref] b2Vec2 value);
    b2Vec2 get(unsigned long index);
    attribute unsigned long length;
};

interface b2Version {
    attribute long major;
    attribute long minor;
    attribute long revision;
};

interface b2WeldJointDef {
    void b2WeldJointDef();
    attribute float angularDampingRatio;
    attribute float angularHertz;
    [Value] attribute b2BodyId bodyIdA;
    [Value] attribute b2BodyId bodyIdB;
    attribute boolean collideConnected;
    attribute long internalValue;
    attribute float linearDampingRatio;
    attribute float linearHertz;
    [Value] attribute b2Vec2 localAnchorA;
    [Value] attribute b2Vec2 localAnchorB;
    attribute float referenceAngle;
    attribute VoidPtr userData;
};

interface b2WheelJointDef {
    void b2WheelJointDef();
    [Value] attribute b2BodyId bodyIdA;
    [Value] attribute b2BodyId bodyIdB;
    attribute boolean collideConnected;
    attribute float dampingRatio;
    attribute boolean enableLimit;
    attribute boolean enableMotor;
    attribute boolean enableSpring;
    attribute float hertz;
    attribute long internalValue;
    [Value] attribute b2Vec2 localAnchorA;
    [Value] attribute b2Vec2 localAnchorB;
    [Value] attribute b2Vec2 localAxisA;
    attribute float lowerTranslation;
    attribute float maxMotorTorque;
    attribute float motorSpeed;
    attribute float upperTranslation;
    attribute VoidPtr userData;
};

interface b2WorldDef {
    void b2WorldDef();
    [Value] attribute b2Vec2 gravity;
    attribute float restitutionThreshold;
    attribute float hitEventThreshold;
    attribute float contactHertz;
    attribute float contactDampingRatio;
    attribute float maxContactPushSpeed;
    attribute float maximumLinearSpeed;
    attribute boolean enableSleep;
    attribute boolean enableContinuous;
    attribute VoidPtr userData;
};

interface b2WorldId {
    void b2WorldId();
    attribute unsigned short generation;
    attribute unsigned short index1;
};

enum b2BodyType {
    "b2_staticBody",
    "b2_kinematicBody",
    "b2_dynamicBody"
};

enum b2JointType {
    "b2_distanceJoint",
    "b2_filterJoint",
    "b2_motorJoint",
    "b2_mouseJoint",
    "b2_prismaticJoint",
    "b2_revoluteJoint",
    "b2_weldJoint",
    "b2_wheelJoint"
};

enum b2ShapeType {
    "b2_circleShape",
    "b2_capsuleShape",
    "b2_segmentShape",
    "b2_polygonShape",
    "b2_chainSegmentShape"
};

enum b2TOIState {
    "b2_toiStateUnknown",
    "b2_toiStateFailed",
    "b2_toiStateOverlapped",
    "b2_toiStateHit",
    "b2_toiStateSeparated"
};

