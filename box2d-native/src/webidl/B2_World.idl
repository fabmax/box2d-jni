[NoDelete]
interface B2_World {
    // World creation and management
    static void defaultWorldDef([Ref] b2WorldDef result);
    static unsigned long long createWorld([Const] b2WorldDef def);
    static void destroyWorld(unsigned long long worldId);
    static boolean isValid(unsigned long long worldId);

    // Simulation
    static void step(unsigned long long worldId, float timeStep, long subStepCount);
    static void draw(unsigned long long worldId, b2DebugDraw draw, b2DebugDrawCallbacks callbacks);

    // Event handling
    [Value] static b2BodyEvents getBodyEvents(unsigned long long worldId);
    [Value] static b2SensorEvents getSensorEvents(unsigned long long worldId);
    [Value] static b2ContactEvents getContactEvents(unsigned long long worldId);

    // Query and collision detection
    [Value] static b2TreeStats overlapAABB(unsigned long long worldId, [Ref] b2AABB aabb, [Ref] b2QueryFilter filter, b2OverlapResultFcnI fcn);
    [Value] static b2TreeStats overlapShape(unsigned long long worldId, [Const] b2ShapeProxy proxy, [Ref] b2QueryFilter filter, b2OverlapResultFcnI fcn);
    [Value] static b2TreeStats castRay(unsigned long long worldId, [Ref] b2Vec2 origin, [Ref] b2Vec2 translation, [Ref] b2QueryFilter filter, b2CastResultFcnI fcn);
    [Value] static b2RayResult castRayClosest(unsigned long long worldId, [Ref] b2Vec2 origin, [Ref] b2Vec2 translation, [Ref] b2QueryFilter filter);
    [Value] static b2TreeStats castShape(unsigned long long worldId, [Const] b2ShapeProxy proxy, [Ref] b2Vec2 translation, [Ref] b2QueryFilter filter, b2CastResultFcnI fcn);
    static float castMover(unsigned long long worldId, [Const] b2Capsule mover, [Ref] b2Vec2 translation, [Ref] b2QueryFilter filter);
    static void collideMover(unsigned long long worldId, [Const] b2Capsule mover, [Ref] b2QueryFilter filter, b2PlaneResultFcnI fcn);

    // World settings
    static void enableSleeping(unsigned long long worldId, boolean flag);
    static boolean isSleepingEnabled(unsigned long long worldId);
    static void enableContinuous(unsigned long long worldId, boolean flag);
    static boolean isContinuousEnabled(unsigned long long worldId);
    static void setRestitutionThreshold(unsigned long long worldId, float value);
    static float getRestitutionThreshold(unsigned long long worldId);
    static void setHitEventThreshold(unsigned long long worldId, float value);
    static float getHitEventThreshold(unsigned long long worldId);
    static void setGravity(unsigned long long worldId, [Ref] b2Vec2 gravity);
    [Value] static b2Vec2 getGravity(unsigned long long worldId);

    // Callbacks
    static void setCustomFilterCallback(unsigned long long worldId, b2CustomFilterFcnI fcn);
    static void setPreSolveCallback(unsigned long long worldId, b2PreSolveFcnI fcn);
    static void setFrictionCallback(unsigned long long worldId, b2FrictionCallbackI callback);
    static void setRestitutionCallback(unsigned long long worldId, b2RestitutionCallbackI callback);

    // Advanced features
    static void explode(unsigned long long worldId, [Const] b2ExplosionDef explosionDef);
    static void setContactTuning(unsigned long long worldId, float hertz, float dampingRatio, float pushSpeed);
    static void setMaximumLinearSpeed(unsigned long long worldId, float maximumLinearSpeed);
    static float getMaximumLinearSpeed(unsigned long long worldId);
    static void enableWarmStarting(unsigned long long worldId, boolean flag);
    static boolean isWarmStartingEnabled(unsigned long long worldId);

    // Statistics and debugging
    static long getAwakeBodyCount(unsigned long long worldId);
    [Value] static b2Profile getProfile(unsigned long long worldId);
    [Value] static b2Counters getCounters(unsigned long long worldId);
    static void dumpMemoryStats(unsigned long long worldId);

    // User data
    static void setUserData(unsigned long long worldId, VoidPtr userData);
    static VoidPtr getUserData(unsigned long long worldId);

    // Internal testing functions
    static void rebuildStaticTree(unsigned long long worldId);
    static void enableSpeculative(unsigned long long worldId, boolean flag);
};

interface TaskManager {
    void install([Ref] b2WorldDef worldDef, long threadCount);
    void executeTask(unsigned long start, unsigned long end, unsigned long threadIndex, unsigned long long box2dTask, unsigned long long box2dContext);
};

[JSImplementation="TaskManager"]
interface TaskManagerImpl {
    void TaskManagerImpl();
    unsigned long long enqueueTask(unsigned long long box2dTask, long itemCount, long minRange, unsigned long long box2dContext);
    void finishTask(unsigned long long userTask);
};

[StackAllocatable]
interface b2BodyEvents {
    void b2BodyEvents();
    attribute long moveCount;
    attribute b2BodyMoveEvent moveEvents;
};

[StackAllocatable]
interface b2BodyMoveEvent {
    void b2BodyMoveEvent();
    [Value] attribute b2BodyId bodyId;
    attribute boolean fellAsleep;
    [Value] attribute b2Transform transform;
    attribute VoidPtr userData;
};

[StackAllocatable]
interface b2SensorEvents {
    void b2SensorEvents();
    attribute long beginCount;
    attribute b2SensorBeginTouchEvent beginEvents;
    attribute long endCount;
    attribute b2SensorEndTouchEvent endEvents;
};

[StackAllocatable]
interface b2SensorBeginTouchEvent {
    void b2SensorBeginTouchEvent();
    [Value] attribute b2ShapeId sensorShapeId;
    [Value] attribute b2ShapeId visitorShapeId;
};

[StackAllocatable]
interface b2SensorEndTouchEvent {
    void b2SensorEndTouchEvent();
    [Value] attribute b2ShapeId sensorShapeId;
    [Value] attribute b2ShapeId visitorShapeId;
};

[StackAllocatable]
interface b2ContactEvents {
    void b2ContactEvents();
    attribute long beginCount;
    attribute b2ContactBeginTouchEvent beginEvents;
    attribute long endCount;
    attribute b2ContactEndTouchEvent endEvents;
    attribute long hitCount;
    attribute b2ContactHitEvent hitEvents;
};

[StackAllocatable]
interface b2ContactBeginTouchEvent {
    void b2ContactBeginTouchEvent();
    [Value] attribute b2Manifold manifold;
    [Value] attribute b2ShapeId shapeIdA;
    [Value] attribute b2ShapeId shapeIdB;
};

[StackAllocatable]
interface b2ContactEndTouchEvent {
    void b2ContactEndTouchEvent();
    [Value] attribute b2ShapeId shapeIdA;
    [Value] attribute b2ShapeId shapeIdB;
};

[StackAllocatable]
interface b2ContactHitEvent {
    void b2ContactHitEvent();
    attribute float approachSpeed;
    [Value] attribute b2Vec2 normal;
    [Value] attribute b2Vec2 point;
    [Value] attribute b2ShapeId shapeIdA;
    [Value] attribute b2ShapeId shapeIdB;
};

[StackAllocatable]
interface b2RayResult {
    void b2RayResult();
    attribute float fraction;
    attribute boolean hit;
    attribute long leafVisits;
    attribute long nodeVisits;
    [Value] attribute b2Vec2 normal;
    [Value] attribute b2Vec2 point;
    [Value] attribute b2ShapeId shapeId;
};

[StackAllocatable]
interface b2TreeStats {
    void b2TreeStats();
    attribute long leafVisits;
    attribute long nodeVisits;
};

[StackAllocatable]
interface b2ExplosionDef {
    void b2ExplosionDef();
    attribute float falloff;
    attribute float impulsePerLength;
    attribute unsigned long long maskBits;
    [Value] attribute b2Vec2 position;
    attribute float radius;
};

[StackAllocatable]
interface b2WorldDef {
    void b2WorldDef();
    [Value] attribute b2Vec2 gravity;
    attribute float restitutionThreshold;
    attribute float hitEventThreshold;
    attribute float contactHertz;
    attribute float contactDampingRatio;
    attribute float maxContactPushSpeed;
    attribute float maximumLinearSpeed;
    attribute boolean enableSleep;
    attribute boolean enableContinuous;
    attribute VoidPtr userData;
};

[StackAllocatable]
interface b2DebugDraw {
    void b2DebugDraw();
    [Value] attribute b2AABB drawingBounds;
    attribute boolean useDrawingBounds;
    attribute boolean drawShapes;
    attribute boolean drawJoints;
    attribute boolean drawJointExtras;
    attribute boolean drawBounds;
    attribute boolean drawMass;
    attribute boolean drawBodyNames;
    attribute boolean drawContacts;
    attribute boolean drawGraphColors;
    attribute boolean drawContactNormals;
    attribute boolean drawContactImpulses;
    attribute boolean drawContactFeatures;
    attribute boolean drawFrictionImpulses;
    attribute boolean drawIslands;
};

interface b2DebugDrawCallbacks { };
interface b2CustomFilterFcnI { };
interface b2PreSolveFcnI { };
interface b2FrictionCallbackI { };
interface b2RestitutionCallbackI { };
interface b2OverlapResultFcnI { };
interface b2CastResultFcnI { };
interface b2PlaneResultFcnI { };

[JSImplementation="b2DebugDrawCallbacks"]
interface b2DebugDrawCallbacksImpl {
    void b2DebugDrawCallbacksImpl();
    void drawPolygon([Const] b2Vec2 vertices, long vertexCount, long color);
    void drawSolidPolygon([Ref] b2Transform transform, [Const] b2Vec2 vertices, long vertexCount, float radius, long color);
    void drawCircle([Ref] b2Vec2 center, float radius, long color);
    void drawSolidCircle([Ref] b2Transform transform, float radius, long color);
    void drawSolidCapsule([Ref] b2Vec2 p1, [Ref] b2Vec2 p2, float radius, long color);
    void drawSegment([Ref] b2Vec2 p1, [Ref] b2Vec2 p2, long color);
    void drawTransform([Ref] b2Transform transform);
    void drawPoint([Ref] b2Vec2 p, float size, long color);
    void drawString([Ref] b2Vec2 p, [Const] DOMString s, long color);
};

[JSImplementation="b2CustomFilterFcnI"]
interface b2CustomFilterFcnImpl {
    void b2CustomFilterFcnImpl();
    boolean customFilterFcn(unsigned long long shapeIdA, unsigned long long shapeIdB);
};

[JSImplementation="b2PreSolveFcnI"]
interface b2PreSolveFcnImpl {
    void b2PreSolveFcnImpl();
    boolean preSolveFcn(unsigned long long shapeIdA, unsigned long long shapeIdB, b2Manifold manifold);
};

[JSImplementation="b2FrictionCallbackI"]
interface b2FrictionCallbackImpl {
    void b2FrictionCallbackImpl();
    float frictionCallback(float frictionA, long userMaterialIdA, float frictionB, long userMaterialIdB);
};

[JSImplementation="b2RestitutionCallbackI"]
interface b2RestitutionCallbackImpl {
    void b2RestitutionCallbackImpl();
    float restitutionCallback(float restitutionA, long userMaterialIdA, float restitutionB, long userMaterialIdB);
};

[JSImplementation="b2OverlapResultFcnI"]
interface b2OverlapResultFcnImpl {
    void b2OverlapResultFcnImpl();
    boolean overlapResultFcn(unsigned long long shapeId);
};

[JSImplementation="b2CastResultFcnI"]
interface b2CastResultFcnImpl {
    void b2CastResultFcnImpl();
    boolean castResultFcn(unsigned long long shapeId, [Ref] b2Vec2 point, [Ref] b2Vec2 normal, float fraction);
};

[JSImplementation="b2PlaneResultFcnI"]
interface b2PlaneResultFcnImpl {
    void b2PlaneResultFcnImpl();
    boolean planeResultFcn(unsigned long long shapeId, [Const] b2PlaneResult plane);
};

interface b2Counters {
    void b2Counters();
    attribute long bodyCount;
    attribute long shapeCount;
    attribute long contactCount;
    attribute long jointCount;
    attribute long islandCount;
    attribute long stackUsed;
    attribute long staticTreeHeight;
    attribute long treeHeight;
    attribute long byteCount;
    attribute long taskCount;
    attribute long[] colorCounts;
};

interface b2Profile {
    void b2Profile();
    attribute float step;
    attribute float pairs;
    attribute float collide;
    attribute float solve;
    attribute float mergeIslands;
    attribute float prepareStages;
    attribute float solveConstraints;
    attribute float prepareConstraints;
    attribute float integrateVelocities;
    attribute float warmStart;
    attribute float solveImpulses;
    attribute float integratePositions;
    attribute float relaxImpulses;
    attribute float applyRestitution;
    attribute float storeImpulses;
    attribute float splitIslands;
    attribute float transforms;
    attribute float hitEvents;
    attribute float refit;
    attribute float bullets;
    attribute float sleepIslands;
    attribute float sensors;
};