[NoDelete]
interface B2_Vec2 {
    static float dot([Ref] b2Vec2 a, [Ref] b2Vec2 b);
    static float cross([Ref] b2Vec2 a, [Ref] b2Vec2 b);
    static void crossVS([Ref] b2Vec2 v, float s, [Ref] b2Vec2 result);
    static void crossSV(float s, [Ref] b2Vec2 v, [Ref] b2Vec2 result);
    static void leftPerp([Ref] b2Vec2 v, [Ref] b2Vec2 result);
    static void rightPerp([Ref] b2Vec2 v, [Ref] b2Vec2 result);
    static void add([Ref] b2Vec2 a, [Ref] b2Vec2 b, [Ref] b2Vec2 result);
    static void sub([Ref] b2Vec2 a, [Ref] b2Vec2 b, [Ref] b2Vec2 result);
    static void neg([Ref] b2Vec2 a, [Ref] b2Vec2 result);
    static void lerp([Ref] b2Vec2 a, [Ref] b2Vec2 b, float t, [Ref] b2Vec2 result);
    static void mul([Ref] b2Vec2 a, [Ref] b2Vec2 b, [Ref] b2Vec2 result);
    static void mulSV(float s, [Ref] b2Vec2 v, [Ref] b2Vec2 result);
    static void mulAdd([Ref] b2Vec2 a, float s, [Ref] b2Vec2 b, [Ref] b2Vec2 result);
    static void mulSub([Ref] b2Vec2 a, float s, [Ref] b2Vec2 b, [Ref] b2Vec2 result);
    static void abs([Ref] b2Vec2 a, [Ref] b2Vec2 result);
    static void min([Ref] b2Vec2 a, [Ref] b2Vec2 b, [Ref] b2Vec2 result);
    static void max([Ref] b2Vec2 a, [Ref] b2Vec2 b, [Ref] b2Vec2 result);
    static void clamp([Ref] b2Vec2 v, [Ref] b2Vec2 a, [Ref] b2Vec2 b, [Ref] b2Vec2 result);
    static float length([Ref] b2Vec2 v);
    static float distance([Ref] b2Vec2 a, [Ref] b2Vec2 b);
    static void normalize([Ref] b2Vec2 v, [Ref] b2Vec2 result);
    static boolean isNormalized([Ref] b2Vec2 a);
    static float getLengthAndNormalize([Ref] b2Vec2 v, [Ref] b2Vec2 result);
    static float lengthSquared([Ref] b2Vec2 v);
    static boolean isValid([Ref] b2Vec2 v);
};

[NoDelete]
interface B2_Rot {
    static float getAngle([Ref] b2Rot q);
    static void getXAxis([Ref] b2Rot q, [Ref] b2Vec2 result);
    static void getYAxis([Ref] b2Rot q, [Ref] b2Vec2 result);
    static void makeRot(float radians, [Ref] b2Rot result);
    static void normalize([Ref] b2Rot q, [Ref] b2Rot result);
    static boolean isNormalized([Ref] b2Rot q);
    static void integrateRotation([Ref] b2Rot q1, float deltaAngle, [Ref] b2Rot result);
    static void nLerp([Ref] b2Rot q1, [Ref] b2Rot q2, float t, [Ref] b2Rot result);
    static void mulRot([Ref] b2Rot q, [Ref] b2Rot r, [Ref] b2Rot result);
    static void invMulRot([Ref] b2Rot q, [Ref] b2Rot r, [Ref] b2Rot result);
    static float relativeAngle([Ref] b2Rot b, [Ref] b2Rot a);
    static float unwindAngle(float radians);
    static void rotateVector([Ref] b2Rot q, [Ref] b2Vec2 v, [Ref] b2Vec2 result);
    static void invRotateVector([Ref] b2Rot q, [Ref] b2Vec2 v, [Ref] b2Vec2 result);
    static float computeAngularVelocity([Ref] b2Rot q1, [Ref] b2Rot q2, float inv_h);
    static void computeRotationBetweenUnitVectors([Ref] b2Vec2 v1, [Ref] b2Vec2 v2, [Ref] b2Rot result);
    static boolean isValid([Ref] b2Rot q);
};

[NoDelete]
interface B2_Transform {
    static void transformPoint([Ref] b2Transform t, [Ref] b2Vec2 p, [Ref] b2Vec2 result);
    static void invTransformPoint([Ref] b2Transform t, [Ref] b2Vec2 p, [Ref] b2Vec2 result);
    static void mulTransforms([Ref] b2Transform A, [Ref] b2Transform B, [Ref] b2Transform result);
    static void invMulTransforms([Ref] b2Transform A, [Ref] b2Transform B, [Ref] b2Transform result);
};

[NoDelete]
interface B2_Mat22 {
    static void mulMV([Ref] b2Mat22 A, [Ref] b2Vec2 v, [Ref] b2Vec2 result);
    static void getInverse22([Ref] b2Mat22 A, [Ref] b2Mat22 result);
    static void solve22([Ref] b2Mat22 A, [Ref] b2Vec2 b, [Ref] b2Vec2 result);
};

[NoDelete]
interface B2_AABB {
    static boolean contains([Ref] b2AABB a, [Ref] b2AABB b);
    static void center([Ref] b2AABB a, [Ref] b2Vec2 result);
    static void extents([Ref] b2AABB a, [Ref] b2Vec2 result);
    static void unionAABB([Ref] b2AABB a, [Ref] b2AABB b, [Ref] b2AABB result);
    static boolean overlaps([Ref] b2AABB a, [Ref] b2AABB b);
    // static void makeAABB([Const] b2Vec2* points, long count, float radius, [Ref] b2AABB result);
    static boolean isValid([Ref] b2AABB aabb);
};

[NoDelete]
interface B2_Plane {
    static float planeSeparation([Ref] b2Plane plane, [Ref] b2Vec2 point);
    static boolean isValid([Ref] b2Plane plane);
};

[NoDelete]
interface B2_Math {
    static void computeCosSin(float radians, [Ref] b2CosSin result);
    static float springDamper(float hertz, float dampingRatio, float position, float velocity, float timeStep);
    static void setLengthUnitsPerMeter(float lengthUnits);
    static float getLengthUnitsPerMeter();

    static boolean isValidFloat(float a);
    static boolean isValidVec2([Ref] b2Vec2 v);
    static boolean isValidRotation([Ref] b2Rot q);
    static boolean isValidAABB([Ref] b2AABB aabb);
    static boolean isValidPlane([Ref] b2Plane a);
};

[StackAllocatable]
interface b2Vec2 {
    void b2Vec2();
    attribute float x;
    attribute float y;
};

[StackAllocatable]
interface b2CosSin {
    void b2CosSin();
    attribute float cosine;
    attribute float sine;
};

[StackAllocatable]
interface b2Rot {
    void b2Rot();
    attribute float c;
    attribute float s;
};

[StackAllocatable]
interface b2Transform {
    void b2Transform();
    [Value] attribute b2Vec2 p;
    [Value] attribute b2Rot q;
};

[StackAllocatable]
interface b2Mat22 {
    void b2Mat22();
    [Value] attribute b2Vec2 cx;
    [Value] attribute b2Vec2 cy;
};

[StackAllocatable]
interface b2AABB {
    void b2AABB();
    [Value] attribute b2Vec2 lowerBound;
    [Value] attribute b2Vec2 upperBound;
};

[StackAllocatable]
interface b2Plane {
    void b2Plane();
    [Value] attribute b2Vec2 normal;
    attribute float offset;
};