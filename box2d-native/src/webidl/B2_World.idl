[NoDelete]
interface B2_World {
    // World creation and management
    static void defaultWorldDef([Ref] b2WorldDef result);
    static void createWorld([Const] b2WorldDef def, [Ref] b2WorldId result);
    static void destroyWorld([Value] b2WorldId result);
    static boolean isValid([Value] b2WorldId id);

    // Simulation
    static void step([Value] b2WorldId world, float timeStep, long subStepCount);
    // static void draw([Value] b2WorldId worldId, b2DebugDraw draw);

    // Event handling
    [Value] static b2BodyEvents getBodyEvents([Value] b2WorldId worldId);
    [Value] static b2SensorEvents getSensorEvents([Value] b2WorldId worldId);
    [Value] static b2ContactEvents getContactEvents([Value] b2WorldId worldId);

    // Query and collision detection
    // [Value] static b2TreeStats overlapAABB([Value] b2WorldId worldId, [Value] b2AABB aabb, [Value] b2QueryFilter filter, b2OverlapResultFcn fcn, VoidPtr context);
    // [Value] static b2TreeStats overlapShape([Value] b2WorldId worldId, [Const] b2ShapeProxy proxy, [Value] b2QueryFilter filter, b2OverlapResultFcn fcn, VoidPtr context);
    // [Value] static b2TreeStats castRay([Value] b2WorldId worldId, [Value] b2Vec2 origin, [Value] b2Vec2 translation, [Value] b2QueryFilter filter, b2CastResultFcn fcn, VoidPtr context);
    // [Value] static b2RayResult castRayClosest([Value] b2WorldId worldId, [Value] b2Vec2 origin, [Value] b2Vec2 translation, [Value] b2QueryFilter filter);
    // [Value] static b2TreeStats castShape([Value] b2WorldId worldId, [Const] b2ShapeProxy proxy, [Value] b2Vec2 translation, [Value] b2QueryFilter filter, b2CastResultFcn fcn, VoidPtr context);
    // static float castMover([Value] b2WorldId worldId, [Const] b2Capsule mover, [Value] b2Vec2 translation, [Value] b2QueryFilter filter);
    // static void collideMover([Value] b2WorldId worldId, [Const] b2Capsule mover, [Value] b2QueryFilter filter, b2PlaneResultFcn fcn, VoidPtr context);

    // World settings
    static void enableSleeping([Value] b2WorldId worldId, boolean flag);
    static boolean isSleepingEnabled([Value] b2WorldId worldId);
    static void enableContinuous([Value] b2WorldId worldId, boolean flag);
    static boolean isContinuousEnabled([Value] b2WorldId worldId);
    static void setRestitutionThreshold([Value] b2WorldId worldId, float value);
    static float getRestitutionThreshold([Value] b2WorldId worldId);
    static void setHitEventThreshold([Value] b2WorldId worldId, float value);
    static float getHitEventThreshold([Value] b2WorldId worldId);
    static void setGravity([Value] b2WorldId worldId, [Value] b2Vec2 gravity);
    [Value] static b2Vec2 getGravity([Value] b2WorldId worldId);

    // Callbacks
    // static void setCustomFilterCallback([Value] b2WorldId worldId, b2CustomFilterFcn fcn, VoidPtr context);
    // static void setPreSolveCallback([Value] b2WorldId worldId, b2PreSolveFcn fcn, VoidPtr context);
    // static void setFrictionCallback([Value] b2WorldId worldId, b2FrictionCallback callback);
    // static void setRestitutionCallback([Value] b2WorldId worldId, b2RestitutionCallback callback);

    // Advanced features
    static void explode([Value] b2WorldId worldId, [Const] b2ExplosionDef explosionDef);
    static void setContactTuning([Value] b2WorldId worldId, float hertz, float dampingRatio, float pushSpeed);
    static void setMaximumLinearSpeed([Value] b2WorldId worldId, float maximumLinearSpeed);
    static float getMaximumLinearSpeed([Value] b2WorldId worldId);
    static void enableWarmStarting([Value] b2WorldId worldId, boolean flag);
    static boolean isWarmStartingEnabled([Value] b2WorldId worldId);

    // Statistics and debugging
    static long getAwakeBodyCount([Value] b2WorldId worldId);
    [Value] static b2Profile getProfile([Value] b2WorldId worldId);
    [Value] static b2Counters getCounters([Value] b2WorldId worldId);
    static void dumpMemoryStats([Value] b2WorldId worldId);

    // User data
    static void setUserData([Value] b2WorldId worldId, VoidPtr userData);
    static VoidPtr getUserData([Value] b2WorldId worldId);

    // Internal testing functions
    static void rebuildStaticTree([Value] b2WorldId worldId);
    static void enableSpeculative([Value] b2WorldId worldId, boolean flag);
};

[StackAllocatable]
interface b2BodyEvents {
    attribute long moveCount;
    attribute b2BodyMoveEvent moveEvents;
};

[StackAllocatable]
interface b2BodyMoveEvent {
    [Value] attribute b2BodyId bodyId;
    attribute boolean fellAsleep;
    [Value] attribute b2Transform transform;
    attribute VoidPtr userData;
};

[StackAllocatable]
interface b2SensorEvents {
    attribute long beginCount;
    attribute b2SensorBeginTouchEvent beginEvents;
    attribute long endCount;
    attribute b2SensorEndTouchEvent endEvents;
};

[StackAllocatable]
interface b2SensorBeginTouchEvent {
    [Value] attribute b2ShapeId sensorShapeId;
    [Value] attribute b2ShapeId visitorShapeId;
};

[StackAllocatable]
interface b2SensorEndTouchEvent {
    [Value] attribute b2ShapeId sensorShapeId;
    [Value] attribute b2ShapeId visitorShapeId;
};

[StackAllocatable]
interface b2ContactEvents {
    attribute long beginCount;
    attribute b2ContactBeginTouchEvent beginEvents;
    attribute long endCount;
    attribute b2ContactEndTouchEvent endEvents;
    attribute long hitCount;
    attribute b2ContactHitEvent hitEvents;
};

[StackAllocatable]
interface b2ContactBeginTouchEvent {
    [Value] attribute b2Manifold manifold;
    [Value] attribute b2ShapeId shapeIdA;
    [Value] attribute b2ShapeId shapeIdB;
};

[StackAllocatable]
interface b2ContactEndTouchEvent {
    [Value] attribute b2ShapeId shapeIdA;
    [Value] attribute b2ShapeId shapeIdB;
};

[StackAllocatable]
interface b2ContactHitEvent {
    attribute float approachSpeed;
    [Value] attribute b2Vec2 normal;
    [Value] attribute b2Vec2 point;
    [Value] attribute b2ShapeId shapeIdA;
    [Value] attribute b2ShapeId shapeIdB;
};

[StackAllocatable]
interface b2Manifold {
    [Value] attribute b2Vec2 normal;
    attribute long pointCount;
    [Value] attribute b2ManifoldPoint[] points;
    attribute float rollingImpulse;
};

[StackAllocatable]
interface b2ManifoldPoint {
    [Value] attribute b2Vec2 anchorA;
    [Value] attribute b2Vec2 anchorB;
    attribute unsigned short id;
    attribute float normalImpulse;
    attribute float normalVelocity;
    attribute boolean persisted;
    [Value] attribute b2Vec2 point;
    attribute float separation;
    attribute float tangentImpulse;
    attribute float totalNormalImpulse;
};

[StackAllocatable]
interface b2ExplosionDef {
    void b2ExplosionDef();
    attribute float falloff;
    attribute float impulsePerLength;
    attribute unsigned long long maskBits;
    [Value] attribute b2Vec2 position;
    attribute float radius;
};

[StackAllocatable]
interface b2WorldDef {
    void b2WorldDef();
    [Value] attribute b2Vec2 gravity;
    attribute float restitutionThreshold;
    attribute float hitEventThreshold;
    attribute float contactHertz;
    attribute float contactDampingRatio;
    attribute float maxContactPushSpeed;
    attribute float maximumLinearSpeed;
    // b2FrictionCallback * 	frictionCallback
    // b2RestitutionCallback * 	restitutionCallback
    attribute boolean enableSleep;
    attribute boolean enableContinuous;
    // attribute long workerCount;
    // b2EnqueueTaskCallback * 	enqueueTask
    // b2FinishTaskCallback * 	finishTask
    // attribute VoidPtr userTaskContext;
    attribute VoidPtr userData;
};

[StackAllocatable]
interface b2WorldId {
    void b2WorldId();
    attribute unsigned short generation;
    attribute unsigned short index1;
};

interface b2Counters {
    void b2Counters();
    attribute long bodyCount;
    attribute long shapeCount;
    attribute long contactCount;
    attribute long jointCount;
    attribute long islandCount;
    attribute long stackUsed;
    attribute long staticTreeHeight;
    attribute long treeHeight;
    attribute long byteCount;
    attribute long taskCount;
    attribute long[] colorCounts;
};

interface b2Profile {
    void b2Profile();
    attribute float step;
    attribute float pairs;
    attribute float collide;
    attribute float solve;
    attribute float mergeIslands;
    attribute float prepareStages;
    attribute float solveConstraints;
    attribute float prepareConstraints;
    attribute float integrateVelocities;
    attribute float warmStart;
    attribute float solveImpulses;
    attribute float integratePositions;
    attribute float relaxImpulses;
    attribute float applyRestitution;
    attribute float storeImpulses;
    attribute float splitIslands;
    attribute float transforms;
    attribute float hitEvents;
    attribute float refit;
    attribute float bullets;
    attribute float sleepIslands;
    attribute float sensors;
};